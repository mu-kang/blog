// Copyright (C) 2006 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

const IN_GLOBAL_SCOPE = true; window.PR_SHOULD_USE_CONTINUATION = true; let prettyPrintOne; let prettyPrint; (function() {
  const P = window; const i = [ 'break,continue,do,else,for,if,return,while' ]; const u = [ i, 'auto,case,char,const,default,' + 'double,enum,extern,float,goto,inline,int,long,register,short,signed,' + 'sizeof,static,struct,switch,typedef,union,unsigned,void,volatile' ]; const p = [ u, 'catch,class,delete,false,import,' + 'new,operator,private,protected,public,this,throw,true,try,typeof' ]; const l = [ p, 'alignof,align_union,asm,axiom,bool,' + 'concept,concept_map,const_cast,constexpr,decltype,delegate,' + 'dynamic_cast,explicit,export,friend,generic,late_check,' + 'mutable,namespace,nullptr,property,reinterpret_cast,static_assert,' + 'static_cast,template,typeid,typename,using,virtual,where' ]; const y = [ p, 'abstract,assert,boolean,byte,extends,final,finally,implements,import,' + 'instanceof,interface,null,native,package,strictfp,super,synchronized,' + 'throws,transient' ]; const U = [ y, 'as,base,by,checked,decimal,delegate,descending,dynamic,event,' + 'fixed,foreach,from,group,implicit,in,internal,into,is,let,' + 'lock,object,out,override,orderby,params,partial,readonly,ref,sbyte,' + 'sealed,stackalloc,string,select,uint,ulong,unchecked,unsafe,ushort,' + 'var,virtual,where' ]; const r = 'all,and,by,catch,class,else,extends,false,finally,' + 'for,if,in,is,isnt,loop,new,no,not,null,of,off,on,or,return,super,then,' + 'throw,true,try,unless,until,when,while,yes'; const x = [ p, 'debugger,eval,export,function,get,null,set,undefined,var,with,' + 'Infinity,NaN' ]; const s = 'caller,delete,die,do,dump,elsif,eval,exit,foreach,for,' + 'goto,if,import,last,local,my,next,no,our,print,package,redo,require,' + 'sub,undef,unless,until,use,wantarray,while,BEGIN,END'; const K = [ i, 'and,as,assert,class,def,del,' + 'elif,except,exec,finally,from,global,import,in,is,lambda,' + 'nonlocal,not,or,pass,print,raise,try,with,yield,' + 'False,True,None' ]; const g = [ i, 'alias,and,begin,case,class,' + 'def,defined,elsif,end,ensure,false,in,module,next,nil,not,or,redo,' + 'rescue,retry,self,super,then,true,undef,unless,until,when,yield,' + 'BEGIN,END' ]; const z = [ i, 'as,assert,const,copy,drop,' + 'enum,extern,fail,false,fn,impl,let,log,loop,match,mod,move,mut,priv,' + 'pub,pure,ref,self,static,struct,true,trait,type,unsafe,use' ]; const J = [ i, 'case,done,elif,esac,eval,fi,' + 'function,in,local,set,then,until' ]; const C = [ l, U, x, s, K, g, J ]; const e = /^(DIR|FILE|vector|(de|priority_)?queue|list|stack|(const_)?iterator|(multi)?(set|map)|bitset|u?(int|float)\d*)\b/; const E = 'str'; const B = 'kwd'; const j = 'com'; const R = 'typ'; const I = 'lit'; const N = 'pun'; const H = 'pln'; const m = 'tag'; const G = 'dec'; const L = 'src'; const S = 'atn'; const n = 'atv'; const Q = 'nocode'; const O = '(?:^^\\.?|[+-]|[!=]=?=?|\\#|%=?|&&?=?|\\(|\\*=?|[+\\-]=|->|\\/=?|::?|<<?=?|>>?>?=?|,|;|\\?|@|\\[|~|{|\\^\\^?=?|\\|\\|?=?|break|case|continue|delete|do|else|finally|instanceof|return|throw|try|typeof)\\s*'; function k(ac) { let ag = 0; let V = false; let af = false; for (var Y = 0, X = ac.length; Y < X; ++Y) { var ah = ac[Y]; if (ah.ignoreCase) { af = true; } else { if (/[a-z]/i.test(ah.source.replace(/\\u[0-9a-f]{4}|\\x[0-9a-f]{2}|\\[^ux]/gi, ''))) { V = true; af = false; break; } } } const ab = { b: 8, t: 9, n: 10, v: 11, f: 12, r: 13 }; function ae(ak) { let aj = ak.charCodeAt(0); if (aj !== 92) { return aj; } const ai = ak.charAt(1); aj = ab[ai]; if (aj) { return aj; } if (ai >= '0' && ai <= '7') { return parseInt(ak.substring(1), 8); } if (ai === 'u' || ai === 'x') { return parseInt(ak.substring(2), 16); } return ak.charCodeAt(1); } function W(ai) { if (ai < 32) { return (ai < 16 ? '\\x0' : '\\x') + ai.toString(16); } const aj = String.fromCharCode(ai); return (aj === '\\' || aj === '-' || aj === ']' || aj === '^') ? '\\' + aj : aj; } function aa(ao) { const at = ao.substring(1, ao.length - 1).match(new RegExp('\\\\u[0-9A-Fa-f]{4}' + '|\\\\x[0-9A-Fa-f]{2}' + '|\\\\[0-3][0-7]{0,2}' + '|\\\\[0-7]{1,2}' + '|\\\\[\\s\\S]' + '|-' + '|[^-\\\\]', 'g')); const ai = []; const aq = at[0] === '^'; const ap = [ '[' ]; if (aq) { ap.push('^'); } for (var au = aq ? 1 : 0, am = at.length; au < am; ++au) { const ak = at[au]; if (/\\[bdsw]/i.test(ak)) { ap.push(ak); } else { const aj = ae(ak); var an; if (au + 2 < am && at[au + 1] === '-') { an = ae(at[au + 2]); au += 2; } else { an = aj; }ai.push([ aj, an ]); if (!(an < 65 || aj > 122)) { if (!(an < 65 || aj > 90)) { ai.push([ Math.max(65, aj) | 32, Math.min(an, 90) | 32 ]); } if (!(an < 97 || aj > 122)) { ai.push([ Math.max(97, aj) & ~32, Math.min(an, 122) & ~32 ]); } } } }ai.sort(function(ax, aw) { return (ax[0] - aw[0]) || (aw[1] - ax[1]); }); const al = []; let ar = []; for (var au = 0; au < ai.length; ++au) { var av = ai[au]; if (av[0] <= ar[1] + 1) { ar[1] = Math.max(ar[1], av[1]); } else { al.push(ar = av); } } for (var au = 0; au < al.length; ++au) { var av = al[au]; ap.push(W(av[0])); if (av[1] > av[0]) { if (av[1] + 1 > av[0]) { ap.push('-'); }ap.push(W(av[1])); } }ap.push(']'); return ap.join(''); } function Z(ao) { const am = ao.source.match(new RegExp('(?:' + '\\[(?:[^\\x5C\\x5D]|\\\\[\\s\\S])*\\]' + '|\\\\u[A-Fa-f0-9]{4}' + '|\\\\x[A-Fa-f0-9]{2}' + '|\\\\[0-9]+' + '|\\\\[^ux0-9]' + '|\\(\\?[:!=]' + '|[\\(\\)\\^]' + '|[^\\x5B\\x5C\\(\\)\\^]+' + ')', 'g')); const ak = am.length; const aq = []; for (var an = 0, ap = 0; an < ak; ++an) { var aj = am[an]; if (aj === '(') { ++ap; } else { if (aj.charAt(0) === '\\') { var ai = +aj.substring(1); if (ai) { if (ai <= ap) { aq[ai] = -1; } else { am[an] = W(ai); } } } } } for (var an = 1; an < aq.length; ++an) { if (aq[an] === -1) { aq[an] = ++ag; } } for (var an = 0, ap = 0; an < ak; ++an) { var aj = am[an]; if (aj === '(') { ++ap; if (!aq[ap]) { am[an] = '(?:'; } } else { if (aj.charAt(0) === '\\') { var ai = +aj.substring(1); if (ai && ai <= ap) { am[an] = '\\' + aq[ai]; } } } } for (var an = 0; an < ak; ++an) { if (am[an] === '^' && am[an + 1] !== '^') { am[an] = ''; } } if (ao.ignoreCase && V) { for (var an = 0; an < ak; ++an) { var aj = am[an]; const al = aj.charAt(0); if (aj.length >= 2 && al === '[') { am[an] = aa(aj); } else { if (al !== '\\') { am[an] = aj.replace(/[a-zA-Z]/g, function(ar) { const at = ar.charCodeAt(0); return '[' + String.fromCharCode(at & ~32, at | 32) + ']'; }); } } } } return am.join(''); } const ad = []; for (var Y = 0, X = ac.length; Y < X; ++Y) { var ah = ac[Y]; if (ah.global || ah.multiline) { throw new Error('' + ah); }ad.push('(?:' + Z(ah) + ')'); } return new RegExp(ad.join('|'), af ? 'gi' : 'g'); } function b(ab, Z) { const X = /(?:^|\s)nocode(?:\s|$)/; const ac = []; let aa = 0; const Y = []; let W = 0; function V(ae) { const ad = ae.nodeType; if (ad == 1) { if (X.test(ae.className)) { return; } for (let ah = ae.firstChild; ah; ah = ah.nextSibling) { V(ah); } const ag = ae.nodeName.toLowerCase(); if (ag === 'br' || ag === 'li') { ac[W] = '\n'; Y[W << 1] = aa++; Y[(W++ << 1) | 1] = ae; } } else { if (ad == 3 || ad == 4) { let af = ae.nodeValue; if (af.length) { if (!Z) { af = af.replace(/[ \t\r\n]+/g, ' '); } else { af = af.replace(/\r\n?/g, '\n'); }ac[W] = af; Y[W << 1] = aa; aa += af.length; Y[(W++ << 1) | 1] = ae; } } } }V(ab); return { sourceCode: ac.join('').replace(/\n$/, ''), spans: Y }; } function D(V, X, Z, W) { if (!X) { return; } const Y = { sourceCode: X, basePos: V }; Z(Y); W.push.apply(W, Y.decorations); } const v = /\S/; function o(V) { let Y; for (let X = V.firstChild; X; X = X.nextSibling) { const W = X.nodeType; Y = (W === 1) ? (Y ? V : X) : (W === 3) ? (v.test(X.nodeValue) ? V : Y) : Y; } return Y === V ? undefined : Y; } function f(X, W) {
    const V = {}; let Y; (function() { const ag = X.concat(W); const ak = []; const aj = {}; for (let ae = 0, ac = ag.length; ae < ac; ++ae) { const ab = ag[ae]; const af = ab[3]; if (af) { for (let ah = af.length; --ah >= 0;) { V[af.charAt(ah)] = ab; } } const ai = ab[1]; const ad = '' + ai; if (!aj.hasOwnProperty(ad)) { ak.push(ai); aj[ad] = null; } }ak.push(/[\0-\uffff]/); Y = k(ak); })(); const aa = W.length; var Z = function(ak) {
      const ac = ak.sourceCode,
        ab = ak.basePos; const ag = [ ab, H ]; let ai = 0; const aq = ac.match(Y) || []; const am = {}; for (let ah = 0, au = aq.length; ah < au; ++ah) { const aj = aq[ah]; let at = am[aj]; let al = void 0; var ap; if (typeof at === 'string') { ap = false; } else { let ad = V[aj.charAt(0)]; if (ad) { al = aj.match(ad[1]); at = ad[0]; } else { for (let ar = 0; ar < aa; ++ar) { ad = W[ar]; al = aj.match(ad[1]); if (al) { at = ad[0]; break; } } if (!al) { at = H; } }ap = at.length >= 5 && at.substring(0, 5) === 'lang-'; if (ap && !(al && typeof al[1] === 'string')) { ap = false; at = L; } if (!ap) { am[aj] = at; } } const ae = ai; ai += aj.length; if (!ap) { ag.push(ab + ae, at); } else { const ao = al[1]; let an = aj.indexOf(ao); let af = an + ao.length; if (al[2]) { af = aj.length - al[2].length; an = af - ao.length; } const av = at.substring(5); D(ab + ae, aj.substring(0, an), Z, ag); D(ab + ae + an, ao, q(av, ao), ag); D(ab + ae + af, aj.substring(af), Z, ag); } }ak.decorations = ag;
    }; return Z;
  } function h(af) {
    const X = [],
      ab = []; if (af.tripleQuotedStrings) { X.push([ E, /^(?:\'\'\'(?:[^\'\\]|\\[\s\S]|\'{1,2}(?=[^\']))*(?:\'\'\'|$)|\"\"\"(?:[^\"\\]|\\[\s\S]|\"{1,2}(?=[^\"]))*(?:\"\"\"|$)|\'(?:[^\\\']|\\[\s\S])*(?:\'|$)|\"(?:[^\\\"]|\\[\s\S])*(?:\"|$))/, null, "'\"" ]); } else { if (af.multiLineStrings) { X.push([ E, /^(?:\'(?:[^\\\']|\\[\s\S])*(?:\'|$)|\"(?:[^\\\"]|\\[\s\S])*(?:\"|$)|\`(?:[^\\\`]|\\[\s\S])*(?:\`|$))/, null, "'\"`" ]); } else { X.push([ E, /^(?:\'(?:[^\\\'\r\n]|\\.)*(?:\'|$)|\"(?:[^\\\"\r\n]|\\.)*(?:\"|$))/, null, "\"'" ]); } } if (af.verbatimStrings) { ab.push([ E, /^@\"(?:[^\"]|\"\")*(?:\"|$)/, null ]); } const ad = af.hashComments; if (ad) { if (af.cStyleComments) { if (ad > 1) { X.push([ j, /^#(?:##(?:[^#]|#(?!##))*(?:###|$)|.*)/, null, '#' ]); } else { X.push([ j, /^#(?:(?:define|e(?:l|nd)if|else|error|ifn?def|include|line|pragma|undef|warning)\b|[^\r\n]*)/, null, '#' ]); }ab.push([ E, /^<(?:(?:(?:\.\.\/)*|\/?)(?:[\w-]+(?:\/[\w-]+)+)?[\w-]+\.h(?:h|pp|\+\+)?|[a-z]\w*)>/, null ]); } else { X.push([ j, /^#[^\r\n]*/, null, '#' ]); } } if (af.cStyleComments) { ab.push([ j, /^\/\/[^\r\n]*/, null ]); ab.push([ j, /^\/\*[\s\S]*?(?:\*\/|$)/, null ]); } const W = af.regexLiterals; if (W) { const Y = W > 1 ? '' : '\n\r'; const aa = Y ? '.' : '[\\S\\s]'; const Z = ('/(?=[^/*' + Y + '])' + '(?:[^/\\x5B\\x5C' + Y + ']' + '|\\x5C' + aa + '|\\x5B(?:[^\\x5C\\x5D' + Y + ']' + '|\\x5C' + aa + ')*(?:\\x5D|$))+' + '/'); ab.push([ 'lang-regex', RegExp('^' + O + '(' + Z + ')') ]); } const ae = af.types; if (ae) { ab.push([ R, ae ]); } const ac = ('' + af.keywords).replace(/^ | $/g, ''); if (ac.length) { ab.push([ B, new RegExp('^(?:' + ac.replace(/[\s,]+/g, '|') + ')\\b'), null ]); }X.push([ H, /^\s+/, null, ' \r\n\t\xA0' ]); let V = "^.[^\\s\\w.$@'\"`/\\\\]*"; if (af.regexLiterals) { V += '(?!s*/)'; }ab.push([ I, /^@[a-z_$][a-z_$@0-9]*/i, null ], [ R, /^(?:[@_]?[A-Z]+[a-z][A-Za-z_$@0-9]*|\w+_t\b)/, null ], [ H, /^[a-z_$][a-z_$@0-9]*/i, null ], [ I, new RegExp('^(?:' + '0x[a-f0-9]+' + '|(?:\\d(?:_\\d+)*\\d*(?:\\.\\d*)?|\\.\\d\\+)' + '(?:e[+\\-]?\\d+)?' + ')' + '[a-z]*', 'i'), null, '0123456789' ], [ H, /^\\[\s\S]?/, null ], [ N, new RegExp(V), null ]); return f(X, ab);
  } const M = h({ keywords: C, hashComments: true, cStyleComments: true, multiLineStrings: true, regexLiterals: true }); function T(X, ai, ab) { const W = /(?:^|\s)nocode(?:\s|$)/; const ad = /\r\n?|\n/; const ae = X.ownerDocument; let ah = ae.createElement('li'); while (X.firstChild) { ah.appendChild(X.firstChild); } const Y = [ ah ]; function ag(ao) { const an = ao.nodeType; if (an == 1 && !W.test(ao.className)) { if (ao.nodeName === 'br') { af(ao); if (ao.parentNode) { ao.parentNode.removeChild(ao); } } else { for (let aq = ao.firstChild; aq; aq = aq.nextSibling) { ag(aq); } } } else { if ((an == 3 || an == 4) && ab) { const ap = ao.nodeValue; const al = ap.match(ad); if (al) { const ak = ap.substring(0, al.index); ao.nodeValue = ak; const aj = ap.substring(al.index + al[0].length); if (aj) { const am = ao.parentNode; am.insertBefore(ae.createTextNode(aj), ao.nextSibling); }af(ao); if (!ak) { ao.parentNode.removeChild(ao); } } } } } function af(am) { while (!am.nextSibling) { am = am.parentNode; if (!am) { return; } } function ak(an, au) { const at = au ? an.cloneNode(false) : an; const aq = an.parentNode; if (aq) { const ar = ak(aq, 1); let ap = an.nextSibling; ar.appendChild(at); for (let ao = ap; ao; ao = ap) { ap = ao.nextSibling; ar.appendChild(ao); } } return at; } let aj = ak(am.nextSibling, 0); for (var al; (al = aj.parentNode) && al.nodeType === 1;) { aj = al; }Y.push(aj); } for (var aa = 0; aa < Y.length; ++aa) { ag(Y[aa]); } if (ai === (ai | 0)) { Y[0].setAttribute('value', ai); } const ac = ae.createElement('ol'); ac.className = 'linenums'; const Z = Math.max(0, ((ai - 1)) | 0) || 0; for (var aa = 0, V = Y.length; aa < V; ++aa) { ah = Y[aa]; ah.className = 'L' + ((aa + Z) % 10); if (!ah.firstChild) { ah.appendChild(ae.createTextNode('\xA0')); }ac.appendChild(ah); }X.appendChild(ac); } function F(ag) {
    let Y = /\bMSIE\s(\d+)/.exec(navigator.userAgent); Y = Y && +Y[1] <= 8; const ap = /\n/g; const ao = ag.sourceCode; const aq = ao.length; let Z = 0; const ae = ag.spans; const W = ae.length; let ak = 0; const ab = ag.decorations; let ac = ab.length; let ad = 0; ab[ac] = aq; let aw,
      au; for (au = aw = 0; au < ac;) { if (ab[au] !== ab[au + 2]) { ab[aw++] = ab[au++]; ab[aw++] = ab[au++]; } else { au += 2; } }ac = aw; for (au = aw = 0; au < ac;) { const ax = ab[au]; const af = ab[au + 1]; var aa = au + 2; while (aa + 2 <= ac && ab[aa + 1] === af) { aa += 2; }ab[aw++] = ax; ab[aw++] = af; au = aa; }ac = ab.length = aw; const av = ag.sourceNode; let al; if (av) { al = av.style.display; av.style.display = 'none'; } try { const ai = null; while (ak < W) { const aj = ae[ak]; const V = ae[ak + 2] || aq; const at = ab[ad + 2] || aq; var aa = Math.min(V, at); let an = ae[ak + 1]; var X; if (an.nodeType !== 1 && (X = ao.substring(Z, aa))) { if (Y) { X = X.replace(ap, '\r'); }an.nodeValue = X; const am = an.ownerDocument; const ar = am.createElement('span'); ar.className = ab[ad + 1]; const ah = an.parentNode; ah.replaceChild(ar, an); ar.appendChild(an); if (Z < V) { ae[ak + 1] = an = am.createTextNode(ao.substring(aa, V)); ah.insertBefore(an, ar.nextSibling); } }Z = aa; if (Z >= V) { ak += 2; } if (Z >= at) { ad += 2; } } } finally { if (av) { av.style.display = al; } }
  } const t = {}; function c(X, Y) { for (let V = Y.length; --V >= 0;) { const W = Y[V]; if (!t.hasOwnProperty(W)) { t[W] = X; } else { if (P.console) { console.warn('cannot override language handler %s', W); } } } } function q(W, V) { if (!(W && t.hasOwnProperty(W))) { W = /^\s*</.test(V) ? 'default-markup' : 'default-code'; } return t[W]; }c(M, [ 'default-code' ]); c(f([], [[ H, /^[^<?]+/ ], [ G, /^<!\w[^>]*(?:>|$)/ ], [ j, /^<\!--[\s\S]*?(?:-\->|$)/ ], [ 'lang-', /^<\?([\s\S]+?)(?:\?>|$)/ ], [ 'lang-', /^<%([\s\S]+?)(?:%>|$)/ ], [ N, /^(?:<[%?]|[%?]>)/ ], [ 'lang-', /^<xmp\b[^>]*>([\s\S]+?)<\/xmp\b[^>]*>/i ], [ 'lang-js', /^<script\b[^>]*>([\s\S]*?)(<\/script\b[^>]*>)/i ], [ 'lang-css', /^<style\b[^>]*>([\s\S]*?)(<\/style\b[^>]*>)/i ], [ 'lang-in.tag', /^(<\/?[a-z][^<>]*>)/i ]]), [ 'default-markup', 'htm', 'html', 'mxml', 'xhtml', 'xml', 'xsl' ]); c(f([[ H, /^[\s]+/, null, ' \t\r\n' ], [ n, /^(?:\"[^\"]*\"?|\'[^\']*\'?)/, null, "\"'" ]], [[ m, /^^<\/?[a-z](?:[\w.:-]*\w)?|\/?>$/i ], [ S, /^(?!style[\s=]|on)[a-z](?:[\w:-]*\w)?/i ], [ 'lang-uq.val', /^=\s*([^>\'\"\s]*(?:[^>\'\"\s\/]|\/(?=\s)))/ ], [ N, /^[=<>\/]+/ ], [ 'lang-js', /^on\w+\s*=\s*\"([^\"]+)\"/i ], [ 'lang-js', /^on\w+\s*=\s*\'([^\']+)\'/i ], [ 'lang-js', /^on\w+\s*=\s*([^\"\'>\s]+)/i ], [ 'lang-css', /^style\s*=\s*\"([^\"]+)\"/i ], [ 'lang-css', /^style\s*=\s*\'([^\']+)\'/i ], [ 'lang-css', /^style\s*=\s*([^\"\'>\s]+)/i ]]), [ 'in.tag' ]); c(f([], [[ n, /^[\s\S]+/ ]]), [ 'uq.val' ]); c(h({ keywords: l, hashComments: true, cStyleComments: true, types: e }), [ 'c', 'cc', 'cpp', 'cxx', 'cyc', 'm' ]); c(h({ keywords: 'null,true,false' }), [ 'json' ]); c(h({ keywords: U, hashComments: true, cStyleComments: true, verbatimStrings: true, types: e }), [ 'cs' ]); c(h({ keywords: y, cStyleComments: true }), [ 'java' ]); c(h({ keywords: J, hashComments: true, multiLineStrings: true }), [ 'bash', 'bsh', 'csh', 'sh' ]); c(h({ keywords: K, hashComments: true, multiLineStrings: true, tripleQuotedStrings: true }), [ 'cv', 'py', 'python' ]); c(h({ keywords: s, hashComments: true, multiLineStrings: true, regexLiterals: 2 }), [ 'perl', 'pl', 'pm' ]); c(h({ keywords: g, hashComments: true, multiLineStrings: true, regexLiterals: true }), [ 'rb', 'ruby' ]); c(h({ keywords: x, cStyleComments: true, regexLiterals: true }), [ 'javascript', 'js' ]); c(h({ keywords: r, hashComments: 3, cStyleComments: true, multilineStrings: true, tripleQuotedStrings: true, regexLiterals: true }), [ 'coffee' ]); c(h({ keywords: z, cStyleComments: true, multilineStrings: true }), [ 'rc', 'rs', 'rust' ]); c(f([], [[ E, /^[\s\S]+/ ]]), [ 'regex' ]); function d(Y) { const X = Y.langExtension; try { const V = b(Y.sourceNode, Y.pre); const W = V.sourceCode; Y.sourceCode = W; Y.spans = V.spans; Y.basePos = 0; q(X, W)(Y); F(Y); } catch (Z) { if (P.console) { console.log(Z && Z.stack || Z); } } } function A(Z, Y, X) { let V = document.createElement('div'); V.innerHTML = '<pre>' + Z + '</pre>'; V = V.firstChild; if (X) { T(V, X, true); } const W = { langExtension: Y, numberLines: X, sourceNode: V, pre: 1 }; d(W); return V.innerHTML; } function w(al, ab) { const ah = ab || document.body; const ao = ah.ownerDocument || document; function aa(aq) { return ah.getElementsByTagName(aq); } let ad = [ aa('pre'), aa('code'), aa('xmp') ]; const ae = []; for (let ak = 0; ak < ad.length; ++ak) { for (let aj = 0, ag = ad[ak].length; aj < ag; ++aj) { ae.push(ad[ak][aj]); } }ad = null; let ap = Date; if (!ap.now) { ap = { now() { return +(new Date()); } }; } let ai = 0; let ac; const X = /\blang(?:uage)?-([\w.]+)(?!\S)/; const an = /\bprettyprint\b/; const W = /\bprettyprinted\b/; const Z = /pre|xmp/i; const V = /^code$/i; const Y = /^(?:pre|code|xmp)$/i; const am = {}; function af() { const ay = (P.PR_SHOULD_USE_CONTINUATION ? ap.now() + 250 : Infinity); for (;ai < ae.length && ap.now() < ay; ai++) { const aA = ae[ai]; var aH = am; for (let ax = aA; (ax = ax.previousSibling);) { const aE = ax.nodeType; const aF = (aE === 7 || aE === 8) && ax.nodeValue; if (aF ? !/^\??prettify\b/.test(aF) : (aE !== 3 || /\S/.test(ax.nodeValue))) { break; } if (aF) { aH = {}; aF.replace(/\b(\w+)=([\w:.%+-]+)/g, function(aJ, aI, aK) { aH[aI] = aK; }); break; } } const aB = aA.className; if ((aH !== am || an.test(aB)) && !W.test(aB)) { let aD = false; for (let au = aA.parentNode; au; au = au.parentNode) { const aG = au.tagName; if (Y.test(aG) && au.className && an.test(au.className)) { aD = true; break; } } if (!aD) { aA.className += ' prettyprinted'; let aw = aH.lang; if (!aw) { aw = aB.match(X); var ar; if (!aw && (ar = o(aA)) && V.test(ar.tagName)) { aw = ar.className.match(X); } if (aw) { aw = aw[1]; } } var av; if (Z.test(aA.tagName)) { av = 1; } else { const at = aA.currentStyle; const az = ao.defaultView; const aq = (at ? at.whiteSpace : (az && az.getComputedStyle) ? az.getComputedStyle(aA, null).getPropertyValue('white-space') : 0); av = aq && aq.substring(0, 3) === 'pre'; } let aC = aH.linenums; if (!(aC = aC === 'true' || +aC)) { aC = aB.match(/\blinenums\b(?::(\d+))?/); aC = aC ? aC[1] && aC[1].length ? +aC[1] : true : false; } if (aC) { T(aA, aC, av); }ac = { langExtension: aw, sourceNode: aA, numberLines: aC, pre: av }; d(ac); } } } if (ai < ae.length) { setTimeout(af, 250); } else { if (typeof al === 'function') { al(); } } }af(); } const a = P.PR = { createSimpleLexer: f, registerLangHandler: c, sourceDecorator: h, PR_ATTRIB_NAME: S, PR_ATTRIB_VALUE: n, PR_COMMENT: j, PR_DECLARATION: G, PR_KEYWORD: B, PR_LITERAL: I, PR_NOCODE: Q, PR_PLAIN: H, PR_PUNCTUATION: N, PR_SOURCE: L, PR_STRING: E, PR_TAG: m, PR_TYPE: R, prettyPrintOne: IN_GLOBAL_SCOPE ? (P.prettyPrintOne = A) : (prettyPrintOne = A), prettyPrint: prettyPrint = IN_GLOBAL_SCOPE ? (P.prettyPrint = w) : (prettyPrint = w) }; if (typeof define === 'function' && define.amd) { define('google-code-prettify', [], function() { return a; }); }
})();
