/* ! Editor.md v1.5.0 | addons.min.js | Open source online markdown editor. | MIT License | By: Pandao | https://github.com/pandao/editor.md | 2015-06-09 */
!function(e) { typeof exports === 'object' && typeof module === 'object' ? e(require('../../lib/codemirror')) : typeof define === 'function' && define.amd ? define([ '../../lib/codemirror' ], e) : e(CodeMirror); }(function(e) { e.defineOption('showTrailingSpace', !1, function(t, i, o) { o == e.Init && (o = !1), o && !i ? t.removeOverlay('trailingspace') : !o && i && t.addOverlay({ token(e) { for (var t = e.string.length, i = t; i && /\s/.test(e.string.charAt(i - 1)); --i);return i > e.pos ? (e.pos = i, null) : (e.pos = t, 'trailingspace'); }, name: 'trailingspace' }); }); }), function(e) { typeof exports === 'object' && typeof module === 'object' ? e(require('../../lib/codemirror')) : typeof define === 'function' && define.amd ? define([ '../../lib/codemirror' ], e) : e(CodeMirror); }(function(e) {
  function t(e, t, i) {
    let o,
      r = e.getWrapperElement(); return o = r.appendChild(document.createElement('div')), i ? o.className = 'CodeMirror-dialog CodeMirror-dialog-bottom' : o.className = 'CodeMirror-dialog CodeMirror-dialog-top', typeof t === 'string' ? o.innerHTML = t : o.appendChild(t), o;
  } function i(e, t) { e.state.currentNotificationClose && e.state.currentNotificationClose(), e.state.currentNotificationClose = t; }e.defineExtension('openDialog', function(o, r, n) {
    function a(e) { if (typeof e === 'string')h.value = e; else { if (c) return; c = !0, l.parentNode.removeChild(l), d.focus(), n.onClose && n.onClose(l); } }n || (n = {}), i(this, null); var s,
      l = t(this, o, n.bottom),
      c = !1,
      d = this,
      h = l.getElementsByTagName('input')[0]; return h ? (n.value && (h.value = n.value, h.select()), n.onInput && e.on(h, 'input', function(e) { n.onInput(e, h.value, a); }), n.onKeyUp && e.on(h, 'keyup', function(e) { n.onKeyUp(e, h.value, a); }), e.on(h, 'keydown', function(t) { n && n.onKeyDown && n.onKeyDown(t, h.value, a) || ((t.keyCode == 27 || n.closeOnEnter !== !1 && t.keyCode == 13) && (h.blur(), e.e_stop(t), a()), t.keyCode == 13 && r(h.value, t)); }), n.closeOnBlur !== !1 && e.on(h, 'blur', a), h.focus()) : (s = l.getElementsByTagName('button')[0]) && (e.on(s, 'click', function() { a(), d.focus(); }), n.closeOnBlur !== !1 && e.on(s, 'blur', a), s.focus()), a;
  }), e.defineExtension('openConfirm', function(o, r, n) {
    function a() { c || (c = !0, s.parentNode.removeChild(s), d.focus()); }i(this, null); var s = t(this, o, n && n.bottom),
      l = s.getElementsByTagName('button'),
      c = !1,
      d = this,
      h = 1; l[0].focus(); for (let u = 0; u < l.length; ++u) { var f = l[u]; !function(t) { e.on(f, 'click', function(i) { e.e_preventDefault(i), a(), t && t(d); }); }(r[u]), e.on(f, 'blur', function() { --h, setTimeout(function() { h <= 0 && a(); }, 200); }), e.on(f, 'focus', function() { ++h; }); }
  }), e.defineExtension('openNotification', function(o, r) {
    function n() { l || (l = !0, clearTimeout(a), s.parentNode.removeChild(s)); }i(this, n); var a,
      s = t(this, o, r && r.bottom),
      l = !1,
      c = r && typeof r.duration !== 'undefined' ? r.duration : 5e3; return e.on(s, 'click', function(t) { e.e_preventDefault(t), n(); }), c && (a = setTimeout(n, c)), n;
  });
}), function(e) { typeof exports === 'object' && typeof module === 'object' ? e(require('../../lib/codemirror')) : typeof define === 'function' && define.amd ? define([ '../../lib/codemirror' ], e) : e(CodeMirror); }(function(e) {
  'use strict'; function t(e, t, r, n) {
    if (this.atOccurrence = !1, this.doc = e, n == null && typeof t === 'string' && (n = !1), r = r ? e.clipPos(r) : o(0, 0), this.pos = { from: r, to: r }, typeof t !== 'string') {
      t.global || (t = new RegExp(t.source, t.ignoreCase ? 'ig' : 'g')), this.matches = function(i, r) {
        if (i) { t.lastIndex = 0; for (var n, a, s = e.getLine(r.line).slice(0, r.ch), l = 0; ;) { t.lastIndex = l; const c = t.exec(s); if (!c) break; if (n = c, a = n.index, l = n.index + (n[0].length || 1), l == s.length) break; } var d = n && n[0].length || 0; d || (a == 0 && s.length == 0 ? n = void 0 : a != e.getLine(r.line).length && d++); } else {
          t.lastIndex = r.ch; var s = e.getLine(r.line),
            n = t.exec(s),
            d = n && n[0].length || 0,
            a = n && n.index; a + d == s.length || d || (d = 1);
        } return n && d ? { from: o(r.line, a), to: o(r.line, a + d), match: n } : void 0;
      };
    } else {
      const a = t; n && (t = t.toLowerCase()); const s = n ? function(e) { return e.toLowerCase(); } : function(e) { return e; },
        l = t.split('\n'); if (l.length == 1) {
        t.length ? this.matches = function(r, n) {
          if (r) {
            var l = e.getLine(n.line).slice(0, n.ch),
              c = s(l),
              d = c.lastIndexOf(t); if (d > -1) return d = i(l, c, d), { from: o(n.line, d), to: o(n.line, d + a.length) };
          } else {
            var l = e.getLine(n.line).slice(n.ch),
              c = s(l),
              d = c.indexOf(t); if (d > -1) return d = i(l, c, d) + n.ch, { from: o(n.line, d), to: o(n.line, d + a.length) };
          }
        } : this.matches = function() {};
      } else {
        const c = a.split('\n'); this.matches = function(t, i) {
          const r = l.length - 1; if (t) {
            if (i.line - (l.length - 1) < e.firstLine()) return; if (s(e.getLine(i.line).slice(0, c[r].length)) != l[l.length - 1]) return; for (var n = o(i.line, c[r].length), a = i.line - 1, d = r - 1; d >= 1; --d, --a) if (l[d] != s(e.getLine(a))) return; var h = e.getLine(a),
              u = h.length - c[0].length; if (s(h.slice(u)) != l[0]) return; return { from: o(a, u), to: n };
          } if (!(i.line + (l.length - 1) > e.lastLine())) {
            var h = e.getLine(i.line),
              u = h.length - c[0].length; if (s(h.slice(u)) == l[0]) { for (var f = o(i.line, u), a = i.line + 1, d = 1; r > d; ++d, ++a) if (l[d] != s(e.getLine(a))) return; if (s(e.getLine(a).slice(0, c[r].length)) == l[r]) return { from: f, to: o(a, c[r].length) }; }
          }
        };
      }
    }
  } function i(e, t, i) { if (e.length == t.length) return i; for (let o = Math.min(i, e.length); ;) { const r = e.slice(0, o).toLowerCase().length; if (i > r)++o; else { if (!(r > i)) return o; --o; } } } var o = e.Pos; t.prototype = { findNext() { return this.find(!1); }, findPrevious() { return this.find(!0); }, find(e) { function t(e) { const t = o(e, 0); return i.pos = { from: t, to: t }, i.atOccurrence = !1, !1; } for (var i = this, r = this.doc.clipPos(e ? this.pos.from : this.pos.to); ;) { if (this.pos = this.matches(e, r)) return this.atOccurrence = !0, this.pos.match || !0; if (e) { if (!r.line) return t(0); r = o(r.line - 1, this.doc.getLine(r.line - 1).length); } else { const n = this.doc.lineCount(); if (r.line == n - 1) return t(n); r = o(r.line + 1, 0); } } }, from() { return this.atOccurrence ? this.pos.from : void 0; }, to() { return this.atOccurrence ? this.pos.to : void 0; }, replace(t) { if (this.atOccurrence) { const i = e.splitLines(t); this.doc.replaceRange(i, this.pos.from, this.pos.to), this.pos.to = o(this.pos.from.line + i.length - 1, i[i.length - 1].length + (i.length == 1 ? this.pos.from.ch : 0)); } } }, e.defineExtension('getSearchCursor', function(e, i, o) { return new t(this.doc, e, i, o); }), e.defineDocExtension('getSearchCursor', function(e, i, o) { return new t(this, e, i, o); }), e.defineExtension('selectMatches', function(t, i) { for (var o, r = [], n = this.getSearchCursor(t, this.getCursor('from'), i); (o = n.findNext()) && !(e.cmpPos(n.to(), this.getCursor('to')) > 0);)r.push({ anchor: n.from(), head: n.to() }); r.length && this.setSelections(r, 0); });
}), function(e) { typeof exports === 'object' && typeof module === 'object' ? e(require('../../lib/codemirror'), require('./searchcursor'), require('../dialog/dialog')) : typeof define === 'function' && define.amd ? define([ '../../lib/codemirror', './searchcursor', '../dialog/dialog' ], e) : e(CodeMirror); }(function(e) {
  'use strict'; function t(e, t) { return typeof e === 'string' ? e = new RegExp(e.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&'), t ? 'gi' : 'g') : e.global || (e = new RegExp(e.source, e.ignoreCase ? 'gi' : 'g')), { token(t) { e.lastIndex = t.pos; const i = e.exec(t.string); return i && i.index == t.pos ? (t.pos += i[0].length, 'searching') : void (i ? t.pos = i.index : t.skipToEnd()); } }; } function i() { this.posFrom = this.posTo = this.query = null, this.overlay = null; } function o(e) { return e.state.search || (e.state.search = new i()); } function r(e) { return typeof e === 'string' && e == e.toLowerCase(); } function n(e, t, i) { return e.getSearchCursor(t, i, r(t)); } function a(e, t, i, o, r) { e.openDialog ? e.openDialog(t, r, { value: o }) : r(prompt(i, o)); } function s(e, t, i, o) { e.openConfirm ? e.openConfirm(t, o) : confirm(i) && o[0](); } function l(e) { const t = e.match(/^\/(.*)\/([a-z]*)$/); if (t) try { e = new RegExp(t[1], t[2].indexOf('i') == -1 ? '' : 'i'); } catch (i) {} return (typeof e === 'string' ? e == '' : e.test('')) && (e = /x^/), e; } function c(e, i) { const n = o(e); return n.query ? d(e, i) : void a(e, f, 'Search for:', e.getSelection(), function(o) { e.operation(function() { o && !n.query && (n.query = l(o), e.removeOverlay(n.overlay, r(n.query)), n.overlay = t(n.query, r(n.query)), e.addOverlay(n.overlay), e.showMatchesOnScrollbar && (n.annotate && (n.annotate.clear(), n.annotate = null), n.annotate = e.showMatchesOnScrollbar(n.query, r(n.query))), n.posFrom = n.posTo = e.getCursor(), d(e, i)); }); }); } function d(t, i) {
    t.operation(function() {
      let r = o(t),
        a = n(t, r.query, i ? r.posFrom : r.posTo); (a.find(i) || (a = n(t, r.query, i ? e.Pos(t.lastLine()) : e.Pos(t.firstLine(), 0)), a.find(i))) && (t.setSelection(a.from(), a.to()), t.scrollIntoView({ from: a.from(), to: a.to() }), r.posFrom = a.from(), r.posTo = a.to());
    });
  } function h(e) { e.operation(function() { const t = o(e); t.query && (t.query = null, e.removeOverlay(t.overlay), t.annotate && (t.annotate.clear(), t.annotate = null)); }); } function u(e, t) {
    e.getOption('readOnly') || a(e, g, 'Replace:', e.getSelection(), function(i) {
      i && (i = l(i), a(e, p, 'Replace with:', '', function(o) {
        if (t)e.operation(function() { for (let t = n(e, i); t.findNext();) if (typeof i !== 'string') { var r = e.getRange(t.from(), t.to()).match(i); t.replace(o.replace(/\$(\d)/g, function(e, t) { return r[t]; })); } else t.replace(o); }); else {
          h(e); var r = n(e, i, e.getCursor()),
            a = function() {
              let t,
                o = r.from(); !(t = r.findNext()) && (r = n(e, i), !(t = r.findNext()) || o && r.from().line == o.line && r.from().ch == o.ch) || (e.setSelection(r.from(), r.to()), e.scrollIntoView({ from: r.from(), to: r.to() }), s(e, m, 'Replace?', [ function() { l(t); }, a ]));
            },
            l = function(e) { r.replace(typeof i === 'string' ? o : o.replace(/\$(\d)/g, function(t, i) { return e[i]; })), a(); }; a();
        }
      }));
    });
  } var f = 'Search: <input type="text" style="width: 10em" class="CodeMirror-search-field"/> <span style="color: #888" class="CodeMirror-search-hint">(Use /re/ syntax for regexp search)</span>',
    g = 'Replace: <input type="text" style="width: 10em" class="CodeMirror-search-field"/> <span style="color: #888" class="CodeMirror-search-hint">(Use /re/ syntax for regexp search)</span>',
    p = 'With: <input type="text" style="width: 10em" class="CodeMirror-search-field"/>',
    m = 'Replace? <button>Yes</button> <button>No</button> <button>Stop</button>'; e.commands.find = function(e) { h(e), c(e); }, e.commands.findNext = c, e.commands.findPrev = function(e) { c(e, !0); }, e.commands.clearSearch = h, e.commands.replace = u, e.commands.replaceAll = function(e) { u(e, !0); };
}), function(e) { typeof exports === 'object' && typeof module === 'object' ? e(require('../../lib/codemirror')) : typeof define === 'function' && define.amd ? define([ '../../lib/codemirror' ], e) : e(CodeMirror); }(function(e) {
  'use strict'; function t(e, t) { function i(e) { clearTimeout(o.doRedraw), o.doRedraw = setTimeout(function() { o.redraw(); }, e); } this.cm = e, this.options = t, this.buttonHeight = t.scrollButtonHeight || e.getOption('scrollButtonHeight'), this.annotations = [], this.doRedraw = this.doUpdate = null, this.div = e.getWrapperElement().appendChild(document.createElement('div')), this.div.style.cssText = 'position: absolute; right: 0; top: 0; z-index: 7; pointer-events: none', this.computeScale(); var o = this; e.on('refresh', this.resizeHandler = function() { clearTimeout(o.doUpdate), o.doUpdate = setTimeout(function() { o.computeScale() && i(20); }, 100); }), e.on('markerAdded', this.resizeHandler), e.on('markerCleared', this.resizeHandler), t.listenForChanges !== !1 && e.on('change', this.changeHandler = function() { i(250); }); }e.defineExtension('annotateScrollbar', function(e) { return typeof e === 'string' && (e = { className: e }), new t(this, e); }), e.defineOption('scrollButtonHeight', 0), t.prototype.computeScale = function() {
    const e = this.cm,
      t = (e.getWrapperElement().clientHeight - e.display.barHeight - 2 * this.buttonHeight) / e.heightAtLine(e.lastLine() + 1, 'local'); return t != this.hScale ? (this.hScale = t, !0) : void 0;
  }, t.prototype.update = function(e) { this.annotations = e, this.redraw(); }, t.prototype.redraw = function(e) {
    e !== !1 && this.computeScale(); const t = this.cm,
      i = this.hScale,
      o = document.createDocumentFragment(),
      r = this.annotations; if (t.display.barWidth) {
      for (var n, a = 0; a < r.length; a++) {
        for (var s = r[a], l = n || t.charCoords(s.from, 'local').top * i, c = t.charCoords(s.to, 'local').bottom * i; a < r.length - 1 && (n = t.charCoords(r[a + 1].from, 'local').top * i, !(n > c + 0.9));)s = r[++a], c = t.charCoords(s.to, 'local').bottom * i; if (c != l) {
          const d = Math.max(c - l, 3),
            h = o.appendChild(document.createElement('div')); h.style.cssText = 'position: absolute; right: 0px; width: ' + Math.max(t.display.barWidth - 1, 2) + 'px; top: ' + (l + this.buttonHeight) + 'px; height: ' + d + 'px', h.className = this.options.className;
        }
      }
    } this.div.textContent = '', this.div.appendChild(o);
  }, t.prototype.clear = function() { this.cm.off('refresh', this.resizeHandler), this.cm.off('markerAdded', this.resizeHandler), this.cm.off('markerCleared', this.resizeHandler), this.changeHandler && this.cm.off('change', this.changeHandler), this.div.parentNode.removeChild(this.div); };
}), function(e) { typeof exports === 'object' && typeof module === 'object' ? e(require('../../lib/codemirror'), require('./searchcursor'), require('../scroll/annotatescrollbar')) : typeof define === 'function' && define.amd ? define([ '../../lib/codemirror', './searchcursor', '../scroll/annotatescrollbar' ], e) : e(CodeMirror); }(function(e) {
  'use strict'; function t(e, t, i, o) { this.cm = e; const r = { listenForChanges: !1 }; for (const n in o)r[n] = o[n]; r.className || (r.className = 'CodeMirror-search-match'), this.annotation = e.annotateScrollbar(r), this.query = t, this.caseFold = i, this.gap = { from: e.firstLine(), to: e.lastLine() + 1 }, this.matches = [], this.update = null, this.findMatches(), this.annotation.update(this.matches); const a = this; e.on('change', this.changeHandler = function(e, t) { a.onChange(t); }); } function i(e, t, i) { return t >= e ? e : Math.max(t, e + i); }e.defineExtension('showMatchesOnScrollbar', function(e, i, o) { return typeof o === 'string' && (o = { className: o }), o || (o = {}), new t(this, e, i, o); }); const o = 1e3; t.prototype.findMatches = function() { if (this.gap) { for (var t = 0; t < this.matches.length; t++) { var i = this.matches[t]; if (i.from.line >= this.gap.to) break; i.to.line >= this.gap.from && this.matches.splice(t--, 1); } for (let r = this.cm.getSearchCursor(this.query, e.Pos(this.gap.from, 0), this.caseFold); r.findNext();) { var i = { from: r.from(), to: r.to() }; if (i.from.line >= this.gap.to) break; if (this.matches.splice(t++, 0, i), this.matches.length > o) break; } this.gap = null; } }, t.prototype.onChange = function(t) {
    const o = t.from.line,
      r = e.changeEnd(t).line,
      n = r - t.to.line; if (this.gap ? (this.gap.from = Math.min(i(this.gap.from, o, n), t.from.line), this.gap.to = Math.max(i(this.gap.to, o, n), t.from.line)) : this.gap = { from: t.from.line, to: r + 1 }, n) {
      for (let a = 0; a < this.matches.length; a++) {
        const s = this.matches[a],
          l = i(s.from.line, o, n); l != s.from.line && (s.from = e.Pos(l, s.from.ch)); const c = i(s.to.line, o, n); c != s.to.line && (s.to = e.Pos(c, s.to.ch));
      }
    }clearTimeout(this.update); const d = this; this.update = setTimeout(function() { d.updateAfterChange(); }, 250);
  }, t.prototype.updateAfterChange = function() { this.findMatches(), this.annotation.update(this.matches); }, t.prototype.clear = function() { this.cm.off('change', this.changeHandler), this.annotation.clear(); };
}), function(e) { typeof exports === 'object' && typeof module === 'object' ? e(require('../../lib/codemirror')) : typeof define === 'function' && define.amd ? define([ '../../lib/codemirror' ], e) : e(CodeMirror); }(function(e) {
  function t(e) { e.state.placeholder && (e.state.placeholder.parentNode.removeChild(e.state.placeholder), e.state.placeholder = null); } function i(e) { t(e); const i = e.state.placeholder = document.createElement('pre'); i.style.cssText = 'height: 0; overflow: visible', i.className = 'CodeMirror-placeholder', i.appendChild(document.createTextNode(e.getOption('placeholder'))), e.display.lineSpace.insertBefore(i, e.display.lineSpace.firstChild); } function o(e) { n(e) && i(e); } function r(e) {
    const o = e.getWrapperElement(),
      r = n(e); o.className = o.className.replace(' CodeMirror-empty', '') + (r ? ' CodeMirror-empty' : ''), r ? i(e) : t(e);
  } function n(e) { return e.lineCount() === 1 && e.getLine(0) === ''; }e.defineOption('placeholder', '', function(i, n, a) { const s = a && a != e.Init; if (n && !s)i.on('blur', o), i.on('change', r), r(i); else if (!n && s) { i.off('blur', o), i.off('change', r), t(i); const l = i.getWrapperElement(); l.className = l.className.replace(' CodeMirror-empty', ''); }n && !i.hasFocus() && o(i); });
}), function(e) { typeof exports === 'object' && typeof module === 'object' ? e(require('../../lib/codemirror'), require('../fold/xml-fold')) : typeof define === 'function' && define.amd ? define([ '../../lib/codemirror', '../fold/xml-fold' ], e) : e(CodeMirror); }(function(e) {
  function t(t) {
    if (t.getOption('disableInput')) return e.Pass; for (var i = t.listSelections(), o = [], l = 0; l < i.length; l++) {
      if (!i[l].empty()) return e.Pass; const c = i[l].head,
        d = t.getTokenAt(c),
        h = e.innerMode(t.getMode(), d.state),
        u = h.state; if (h.mode.name != 'xml' || !u.tagName) return e.Pass; let f = t.getOption('autoCloseTags'),
        g = h.mode.configuration == 'html',
        p = typeof f === 'object' && f.dontCloseTags || g && a,
        m = typeof f === 'object' && f.indentTags || g && s,
        v = u.tagName; d.end > c.ch && (v = v.slice(0, v.length - d.end + c.ch)); const w = v.toLowerCase(); if (!v || d.type == 'string' && (d.end != c.ch || !/[\"\']/.test(d.string.charAt(d.string.length - 1)) || d.string.length == 1) || d.type == 'tag' && u.type == 'closeTag' || d.string.indexOf('/') == d.string.length - 1 || p && r(p, w) > -1 || n(t, v, c, u, !0)) return e.Pass; const b = m && r(m, w) > -1; o[l] = { indent: b, text: '>' + (b ? '\n\n' : '') + '</' + v + '>', newPos: b ? e.Pos(c.line + 1, 0) : e.Pos(c.line, c.ch + 1) };
    } for (var l = i.length - 1; l >= 0; l--) { const y = o[l]; t.replaceRange(y.text, i[l].head, i[l].anchor, '+insert'); const k = t.listSelections().slice(0); k[l] = { head: y.newPos, anchor: y.newPos }, t.setSelections(k), y.indent && (t.indentLine(y.newPos.line, null, !0), t.indentLine(y.newPos.line + 1, null, !0)); }
  } function i(t, i) {
    for (var o = t.listSelections(), r = [], a = i ? '/' : '</', s = 0; s < o.length; s++) {
      if (!o[s].empty()) return e.Pass; const l = o[s].head,
        c = t.getTokenAt(l),
        d = e.innerMode(t.getMode(), c.state),
        h = d.state; if (i && (c.type == 'string' || c.string.charAt(0) != '<' || c.start != l.ch - 1)) return e.Pass; if (d.mode.name != 'xml') if (t.getMode().name == 'htmlmixed' && d.mode.name == 'javascript')r[s] = a + 'script>'; else { if (t.getMode().name != 'htmlmixed' || d.mode.name != 'css') return e.Pass; r[s] = a + 'style>'; } else { if (!h.context || !h.context.tagName || n(t, h.context.tagName, l, h)) return e.Pass; r[s] = a + h.context.tagName + '>'; }
    }t.replaceSelections(r), o = t.listSelections(); for (var s = 0; s < o.length; s++)(s == o.length - 1 || o[s].head.line < o[s + 1].head.line) && t.indentLine(o[s].head.line);
  } function o(t) { return t.getOption('disableInput') ? e.Pass : i(t, !0); } function r(e, t) { if (e.indexOf) return e.indexOf(t); for (let i = 0, o = e.length; o > i; ++i) if (e[i] == t) return i; return -1; } function n(t, i, o, r, n) {
    if (!e.scanForClosingTag) return !1; const a = Math.min(t.lastLine() + 1, o.line + 500),
      s = e.scanForClosingTag(t, o, null, a); if (!s || s.tag != i) return !1; for (var l = r.context, c = n ? 1 : 0; l && l.tagName == i; l = l.prev)++c; o = s.to; for (let d = 1; c > d; d++) { const h = e.scanForClosingTag(t, o, null, a); if (!h || h.tag != i) return !1; o = h.to; } return !0;
  }e.defineOption('autoCloseTags', !1, function(i, r, n) { if (n != e.Init && n && i.removeKeyMap('autoCloseTags'), r) { const a = { name: 'autoCloseTags' }; (typeof r !== 'object' || r.whenClosing) && (a["'/'"] = function(e) { return o(e); }), (typeof r !== 'object' || r.whenOpening) && (a["'>'"] = function(e) { return t(e); }), i.addKeyMap(a); } }); var a = [ 'area', 'base', 'br', 'col', 'command', 'embed', 'hr', 'img', 'input', 'keygen', 'link', 'meta', 'param', 'source', 'track', 'wbr' ],
    s = [ 'applet', 'blockquote', 'body', 'button', 'div', 'dl', 'fieldset', 'form', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'html', 'iframe', 'layer', 'legend', 'object', 'ol', 'p', 'select', 'table', 'ul' ]; e.commands.closeTag = function(e) { return i(e); };
}), function(e) { typeof exports === 'object' && typeof module === 'object' ? e(require('../../lib/codemirror')) : typeof define === 'function' && define.amd ? define([ '../../lib/codemirror' ], e) : e(CodeMirror); }(function(e) {
  'use strict'; function t(t, r, n, a) {
    function s(e) { const i = l(t, r); if (!i || i.to.line - i.from.line < c) return null; for (let o = t.findMarksAt(i.from), n = 0; n < o.length; ++n) if (o[n].__isFold && a !== 'fold') { if (!e) return null; i.cleared = !0, o[n].clear(); } return i; } if (n && n.call) { var l = n; n = null; } else var l = o(t, n, 'rangeFinder'); typeof r === 'number' && (r = e.Pos(r, 0)); var c = o(t, n, 'minFoldSize'),
      d = s(!0); if (o(t, n, 'scanUp')) for (;!d && r.line > t.firstLine();)r = e.Pos(r.line - 1, 0), d = s(!1); if (d && !d.cleared && a !== 'unfold') { const h = i(t, n); e.on(h, 'mousedown', function(t) { u.clear(), e.e_preventDefault(t); }); var u = t.markText(d.from, d.to, { replacedWith: h, clearOnEnter: !0, __isFold: !0 }); u.on('clear', function(i, o) { e.signal(t, 'unfold', t, i, o); }), e.signal(t, 'fold', t, d.from, d.to); }
  } function i(e, t) { let i = o(e, t, 'widget'); if (typeof i === 'string') { const r = document.createTextNode(i); i = document.createElement('span'), i.appendChild(r), i.className = 'CodeMirror-foldmarker'; } return i; } function o(e, t, i) { if (t && void 0 !== t[i]) return t[i]; const o = e.options.foldOptions; return o && void 0 !== o[i] ? o[i] : r[i]; }e.newFoldFunction = function(e, i) { return function(o, r) { t(o, r, { rangeFinder: e, widget: i }); }; }, e.defineExtension('foldCode', function(e, i, o) { t(this, e, i, o); }), e.defineExtension('isFolded', function(e) { for (let t = this.findMarksAt(e), i = 0; i < t.length; ++i) if (t[i].__isFold) return !0; }), e.commands.toggleFold = function(e) { e.foldCode(e.getCursor()); }, e.commands.fold = function(e) { e.foldCode(e.getCursor(), null, 'fold'); }, e.commands.unfold = function(e) { e.foldCode(e.getCursor(), null, 'unfold'); }, e.commands.foldAll = function(t) { t.operation(function() { for (let i = t.firstLine(), o = t.lastLine(); o >= i; i++)t.foldCode(e.Pos(i, 0), null, 'fold'); }); }, e.commands.unfoldAll = function(t) { t.operation(function() { for (let i = t.firstLine(), o = t.lastLine(); o >= i; i++)t.foldCode(e.Pos(i, 0), null, 'unfold'); }); }, e.registerHelper('fold', 'combine', function() { const e = Array.prototype.slice.call(arguments, 0); return function(t, i) { for (let o = 0; o < e.length; ++o) { const r = e[o](t, i); if (r) return r; } }; }), e.registerHelper('fold', 'auto', function(e, t) { for (let i = e.getHelpers(t, 'fold'), o = 0; o < i.length; o++) { const r = i[o](e, t); if (r) return r; } }); var r = { rangeFinder: e.fold.auto, widget: 'â†”', minFoldSize: 0, scanUp: !1 }; e.defineOption('foldOptions', null), e.defineExtension('foldOption', function(e, t) { return o(this, e, t); });
}), function(e) { typeof exports === 'object' && typeof module === 'object' ? e(require('../../lib/codemirror'), require('./foldcode')) : typeof define === 'function' && define.amd ? define([ '../../lib/codemirror', './foldcode' ], e) : e(CodeMirror); }(function(e) {
  'use strict'; function t(e) { this.options = e, this.from = this.to = 0; } function i(e) { return e === !0 && (e = {}), e.gutter == null && (e.gutter = 'CodeMirror-foldgutter'), e.indicatorOpen == null && (e.indicatorOpen = 'CodeMirror-foldgutter-open'), e.indicatorFolded == null && (e.indicatorFolded = 'CodeMirror-foldgutter-folded'), e; } function o(e, t) { for (let i = e.findMarksAt(h(t)), o = 0; o < i.length; ++o) if (i[o].__isFold && i[o].find().from.line == t) return !0; } function r(e) { if (typeof e === 'string') { const t = document.createElement('div'); return t.className = e + ' CodeMirror-guttermarker-subtle', t; } return e.cloneNode(!0); } function n(e, t, i) {
    let n = e.state.foldGutter.options,
      a = t,
      s = e.foldOption(n, 'minFoldSize'),
      l = e.foldOption(n, 'rangeFinder'); e.eachLine(t, i, function(t) {
      let i = null; if (o(e, a))i = r(n.indicatorFolded); else {
        const c = h(a, 0),
          d = l && l(e, c); d && d.to.line - d.from.line >= s && (i = r(n.indicatorOpen));
      }e.setGutterMarker(t, n.gutter, i), ++a;
    });
  } function a(e) {
    const t = e.getViewport(),
      i = e.state.foldGutter; i && (e.operation(function() { n(e, t.from, t.to); }), i.from = t.from, i.to = t.to);
  } function s(e, t, i) { const o = e.state.foldGutter; if (o) { const r = o.options; i == r.gutter && e.foldCode(h(t, 0), r.rangeFinder); } } function l(e) { const t = e.state.foldGutter; if (t) { const i = t.options; t.from = t.to = 0, clearTimeout(t.changeUpdate), t.changeUpdate = setTimeout(function() { a(e); }, i.foldOnChangeTimeSpan || 600); } } function c(e) { const t = e.state.foldGutter; if (t) { const i = t.options; clearTimeout(t.changeUpdate), t.changeUpdate = setTimeout(function() { const i = e.getViewport(); t.from == t.to || i.from - t.to > 20 || t.from - i.to > 20 ? a(e) : e.operation(function() { i.from < t.from && (n(e, i.from, t.from), t.from = i.from), i.to > t.to && (n(e, t.to, i.to), t.to = i.to); }); }, i.updateViewportTimeSpan || 400); } } function d(e, t) { const i = e.state.foldGutter; if (i) { const o = t.line; o >= i.from && o < i.to && n(e, o, o + 1); } }e.defineOption('foldGutter', !1, function(o, r, n) { n && n != e.Init && (o.clearGutter(o.state.foldGutter.options.gutter), o.state.foldGutter = null, o.off('gutterClick', s), o.off('change', l), o.off('viewportChange', c), o.off('fold', d), o.off('unfold', d), o.off('swapDoc', a)), r && (o.state.foldGutter = new t(i(r)), a(o), o.on('gutterClick', s), o.on('change', l), o.on('viewportChange', c), o.on('fold', d), o.on('unfold', d), o.on('swapDoc', a)); }); var h = e.Pos;
}), function(e) { typeof exports === 'object' && typeof module === 'object' ? e(require('../../lib/codemirror')) : typeof define === 'function' && define.amd ? define([ '../../lib/codemirror' ], e) : e(CodeMirror); }(function(e) {
  'use strict'; e.registerHelper('fold', 'indent', function(t, i) {
    const o = t.getOption('tabSize'),
      r = t.getLine(i.line); if (/\S/.test(r)) {
      for (var n = function(t) { return e.countColumn(t, null, o); }, a = n(r), s = null, l = i.line + 1, c = t.lastLine(); c >= l; ++l) {
        const d = t.getLine(l),
          h = n(d); if (h > a)s = l; else if (/\S/.test(d)) break;
      } return s ? { from: e.Pos(i.line, r.length), to: e.Pos(s, t.getLine(s).length) } : void 0;
    }
  });
}), function(e) { typeof exports === 'object' && typeof module === 'object' ? e(require('../../lib/codemirror')) : typeof define === 'function' && define.amd ? define([ '../../lib/codemirror' ], e) : e(CodeMirror); }(function(e) {
  'use strict'; e.registerHelper('fold', 'brace', function(t, i) {
    function o(o) { for (let r = i.ch, l = 0; ;) { const c = r <= 0 ? -1 : s.lastIndexOf(o, r - 1); if (c != -1) { if (l == 1 && c < i.ch) break; if (n = t.getTokenTypeAt(e.Pos(a, c + 1)), !/^(comment|string)/.test(n)) return c + 1; r = c - 1; } else { if (l == 1) break; l = 1, r = s.length; } } } var r,
      n,
      a = i.line,
      s = t.getLine(a),
      l = '{',
      c = '}',
      r = o('{'); if (r == null && (l = '[', c = ']', r = o('[')), r != null) {
      let d,
        h,
        u = 1,
        f = t.lastLine(); e:for (let g = a; f >= g; ++g) {
        for (let p = t.getLine(g), m = g == a ? r : 0; ;) {
          let v = p.indexOf(l, m),
            w = p.indexOf(c, m); if (v < 0 && (v = p.length), w < 0 && (w = p.length), m = Math.min(v, w), m == p.length) break; if (t.getTokenTypeAt(e.Pos(g, m + 1)) == n) if (m == v)++u; else if (!--u) { d = g, h = m; break e; }++m;
        }
      } if (d != null && (a != d || h != r)) return { from: e.Pos(a, r), to: e.Pos(d, h) };
    }
  }), e.registerHelper('fold', 'import', function(t, i) {
    function o(i) {
      if (i < t.firstLine() || i > t.lastLine()) return null; let o = t.getTokenAt(e.Pos(i, 1)); if (/\S/.test(o.string) || (o = t.getTokenAt(e.Pos(i, o.end + 1))), o.type != 'keyword' || o.string != 'import') return null; for (let r = i, n = Math.min(t.lastLine(), i + 10); n >= r; ++r) {
        const a = t.getLine(r),
          s = a.indexOf(';'); if (s != -1) return { startCh: o.end, end: e.Pos(r, s) };
      }
    } var r,
      i = i.line,
      n = o(i); if (!n || o(i - 1) || (r = o(i - 2)) && r.end.line == i - 1) return null; for (var a = n.end; ;) { const s = o(a.line + 1); if (s == null) break; a = s.end; } return { from: t.clipPos(e.Pos(i, n.startCh + 1)), to: a };
  }), e.registerHelper('fold', 'include', function(t, i) {
    function o(i) { if (i < t.firstLine() || i > t.lastLine()) return null; let o = t.getTokenAt(e.Pos(i, 1)); return /\S/.test(o.string) || (o = t.getTokenAt(e.Pos(i, o.end + 1))), o.type == 'meta' && o.string.slice(0, 8) == '#include' ? o.start + 8 : void 0; } var i = i.line,
      r = o(i); if (r == null || o(i - 1) != null) return null; for (var n = i; ;) { const a = o(n + 1); if (a == null) break; ++n; } return { from: e.Pos(i, r + 1), to: t.clipPos(e.Pos(n)) };
  });
}), function(e) { typeof exports === 'object' && typeof module === 'object' ? e(require('../../lib/codemirror')) : typeof define === 'function' && define.amd ? define([ '../../lib/codemirror' ], e) : e(CodeMirror); }(function(e) {
  'use strict'; function t(e, t) { return e.line - t.line || e.ch - t.ch; } function i(e, t, i, o) { this.line = t, this.ch = i, this.cm = e, this.text = e.getLine(t), this.min = o ? o.from : e.firstLine(), this.max = o ? o.to - 1 : e.lastLine(); } function o(e, t) { const i = e.cm.getTokenTypeAt(u(e.line, t)); return i && /\btag\b/.test(i); } function r(e) { return e.line >= e.max ? void 0 : (e.ch = 0, e.text = e.cm.getLine(++e.line), !0); } function n(e) { return e.line <= e.min ? void 0 : (e.text = e.cm.getLine(--e.line), e.ch = e.text.length, !0); } function a(e) {
    for (;;) {
      const t = e.text.indexOf('>', e.ch); if (t == -1) { if (r(e)) continue; return; } { if (o(e, t + 1)) {
        const i = e.text.lastIndexOf('/', t),
          n = i > -1 && !/\S/.test(e.text.slice(i + 1, t)); return e.ch = t + 1, n ? 'selfClose' : 'regular';
      }e.ch = t + 1; }
    }
  } function s(e) { for (;;) { const t = e.ch ? e.text.lastIndexOf('<', e.ch - 1) : -1; if (t == -1) { if (n(e)) continue; return; } if (o(e, t + 1)) { p.lastIndex = t, e.ch = t; const i = p.exec(e.text); if (i && i.index == t) return i; } else e.ch = t; } } function l(e) { for (;;) { p.lastIndex = e.ch; const t = p.exec(e.text); if (!t) { if (r(e)) continue; return; } { if (o(e, t.index + 1)) return e.ch = t.index + t[0].length, t; e.ch = t.index + 1; } } } function c(e) {
    for (;;) {
      const t = e.ch ? e.text.lastIndexOf('>', e.ch - 1) : -1; if (t == -1) { if (n(e)) continue; return; } { if (o(e, t + 1)) {
        const i = e.text.lastIndexOf('/', t),
          r = i > -1 && !/\S/.test(e.text.slice(i + 1, t)); return e.ch = t + 1, r ? 'selfClose' : 'regular';
      }e.ch = t; }
    }
  } function d(e, t) {
    for (let i = []; ;) {
      var o,
        r = l(e),
        n = e.line,
        s = e.ch - (r ? r[0].length : 0); if (!r || !(o = a(e))) return; if (o != 'selfClose') if (r[1]) { for (var c = i.length - 1; c >= 0; --c) if (i[c] == r[2]) { i.length = c; break; } if (c < 0 && (!t || t == r[2])) return { tag: r[2], from: u(n, s), to: u(e.line, e.ch) }; } else i.push(r[2]);
    }
  } function h(e, t) {
    for (let i = []; ;) {
      const o = c(e); if (!o) return; if (o != 'selfClose') {
        const r = e.line,
          n = e.ch,
          a = s(e); if (!a) return; if (a[1])i.push(a[2]); else { for (var l = i.length - 1; l >= 0; --l) if (i[l] == a[2]) { i.length = l; break; } if (l < 0 && (!t || t == a[2])) return { tag: a[2], from: u(e.line, e.ch), to: u(r, n) }; }
      } else s(e);
    }
  } var u = e.Pos,
    f = 'A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD',
    g = f + '-:.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040',
    p = new RegExp('<(/?)([' + f + '][' + g + ']*)', 'g'); e.registerHelper('fold', 'xml', function(e, t) {
    for (let o = new i(e, t.line, 0); ;) {
      var r,
        n = l(o); if (!n || o.line != t.line || !(r = a(o))) return; if (!n[1] && r != 'selfClose') {
        var t = u(o.line, o.ch),
          s = d(o, n[2]); return s && { from: t, to: s.from };
      }
    }
  }), e.findMatchingTag = function(e, o, r) {
    let n = new i(e, o.line, o.ch, r); if (n.text.indexOf('>') != -1 || n.text.indexOf('<') != -1) {
      const l = a(n),
        c = l && u(n.line, n.ch),
        f = l && s(n); if (l && f && !(t(n, o) > 0)) { const g = { from: u(n.line, n.ch), to: c, tag: f[2] }; return l == 'selfClose' ? { open: g, close: null, at: 'open' } : f[1] ? { open: h(n, f[2]), close: g, at: 'close' } : (n = new i(e, c.line, c.ch, r), { open: g, close: d(n, f[2]), at: 'open' }); }
    }
  }, e.findEnclosingTag = function(e, t, o) {
    for (let r = new i(e, t.line, t.ch, o); ;) {
      const n = h(r); if (!n) break; const a = new i(e, t.line, t.ch, o),
        s = d(a, n.tag); if (s) return { open: n, close: s };
    }
  }, e.scanForClosingTag = function(e, t, o, r) { const n = new i(e, t.line, t.ch, r ? { from: 0, to: r } : null); return d(n, o); };
}), function(e) { typeof exports === 'object' && typeof module === 'object' ? e(require('../../lib/codemirror')) : typeof define === 'function' && define.amd ? define([ '../../lib/codemirror' ], e) : e(CodeMirror); }(function(e) {
  'use strict'; e.registerHelper('fold', 'markdown', function(t, i) {
    function o(i) { const o = t.getTokenTypeAt(e.Pos(i, 0)); return o && /\bheader\b/.test(o); } function r(e, t, i) { let r = t && t.match(/^#+/); return r && o(e) ? r[0].length : (r = i && i.match(/^[=\-]+\s*$/), r && o(e + 1) ? i[0] == '=' ? 1 : 2 : n); } var n = 100,
      a = t.getLine(i.line),
      s = t.getLine(i.line + 1),
      l = r(i.line, a, s); if (l === n) return void 0; for (var c = t.lastLine(), d = i.line, h = t.getLine(d + 2); c > d && !(r(d + 1, s, h) <= l);)++d, s = h, h = t.getLine(d + 2); return { from: e.Pos(i.line, a.length), to: e.Pos(d, t.getLine(d).length) };
  });
}), function(e) { typeof exports === 'object' && typeof module === 'object' ? e(require('../../lib/codemirror')) : typeof define === 'function' && define.amd ? define([ '../../lib/codemirror' ], e) : e(CodeMirror); }(function(e) {
  'use strict'; e.registerGlobalHelper('fold', 'comment', function(e) { return e.blockCommentStart && e.blockCommentEnd; }, function(t, i) {
    const o = t.getModeAt(i),
      r = o.blockCommentStart,
      n = o.blockCommentEnd; if (r && n) {
      for (var a, s = i.line, l = t.getLine(s), c = i.ch, d = 0; ;) { const h = c <= 0 ? -1 : l.lastIndexOf(r, c - 1); if (h != -1) { if (d == 1 && h < i.ch) return; if (/comment/.test(t.getTokenTypeAt(e.Pos(s, h + 1)))) { a = h + r.length; break; }c = h - 1; } else { if (d == 1) return; d = 1, c = l.length; } } let u,
        f,
        g = 1,
        p = t.lastLine(); e:for (let m = s; p >= m; ++m) {
        for (let v = t.getLine(m), w = m == s ? a : 0; ;) {
          let b = v.indexOf(r, w),
            y = v.indexOf(n, w); if (b < 0 && (b = v.length), y < 0 && (y = v.length), w = Math.min(b, y), w == v.length) break; if (w == b)++g; else if (!--g) { u = m, f = w; break e; }++w;
        }
      } if (u != null && (s != u || f != a)) return { from: e.Pos(s, a), to: e.Pos(u, f) };
    }
  });
}), function(e) { typeof exports === 'object' && typeof module === 'object' ? e(require('../../lib/codemirror')) : typeof define === 'function' && define.amd ? define([ '../../lib/codemirror' ], e) : e(CodeMirror); }(function(e) { 'use strict'; e.overlayMode = function(t, i, o) { return { startState() { return { base: e.startState(t), overlay: e.startState(i), basePos: 0, baseCur: null, overlayPos: 0, overlayCur: null, streamSeen: null }; }, copyState(o) { return { base: e.copyState(t, o.base), overlay: e.copyState(i, o.overlay), basePos: o.basePos, baseCur: null, overlayPos: o.overlayPos, overlayCur: null }; }, token(e, r) { return (e != r.streamSeen || Math.min(r.basePos, r.overlayPos) < e.start) && (r.streamSeen = e, r.basePos = r.overlayPos = e.start), e.start == r.basePos && (r.baseCur = t.token(e, r.base), r.basePos = e.pos), e.start == r.overlayPos && (e.pos = e.start, r.overlayCur = i.token(e, r.overlay), r.overlayPos = e.pos), e.pos = Math.min(r.basePos, r.overlayPos), r.overlayCur == null ? r.baseCur : r.baseCur != null && r.overlay.combineTokens || o && r.overlay.combineTokens == null ? r.baseCur + ' ' + r.overlayCur : r.overlayCur; }, indent: t.indent && function(e, i) { return t.indent(e.base, i); }, electricChars: t.electricChars, innerMode(e) { return { state: e.base, mode: t }; }, blankLine(e) { t.blankLine && t.blankLine(e.base), i.blankLine && i.blankLine(e.overlay); } }; }; }), function(e) {
  typeof exports === 'object' && typeof module === 'object' ? e(require('../../lib/codemirror')) : typeof define === 'function' && define.amd ? define([ '../../lib/codemirror' ], e) : e(CodeMirror);

}(function(e) {
  'use strict'; function t(e) { for (let t = 0; t < e.state.activeLines.length; t++)e.removeLineClass(e.state.activeLines[t], 'wrap', n), e.removeLineClass(e.state.activeLines[t], 'background', a); } function i(e, t) { if (e.length != t.length) return !1; for (let i = 0; i < e.length; i++) if (e[i] != t[i]) return !1; return !0; } function o(e, o) { for (var r = [], s = 0; s < o.length; s++) { const l = o[s]; if (l.empty()) { const c = e.getLineHandleVisualStart(l.head.line); r[r.length - 1] != c && r.push(c); } }i(e.state.activeLines, r) || e.operation(function() { t(e); for (let i = 0; i < r.length; i++)e.addLineClass(r[i], 'wrap', n), e.addLineClass(r[i], 'background', a); e.state.activeLines = r; }); } function r(e, t) { o(e, t.ranges); } var n = 'CodeMirror-activeline',
    a = 'CodeMirror-activeline-background'; e.defineOption('styleActiveLine', !1, function(i, n, a) { const s = a && a != e.Init; n && !s ? (i.state.activeLines = [], o(i, i.listSelections()), i.on('beforeSelectionChange', r)) : !n && s && (i.off('beforeSelectionChange', r), t(i), delete i.state.activeLines); });
}), function(e) { typeof exports === 'object' && typeof module === 'object' ? e(require('../../lib/codemirror')) : typeof define === 'function' && define.amd ? define([ '../../lib/codemirror' ], e) : e(CodeMirror); }(function(e) {
  function t(e, t) { const i = e.getRange(c(t.line, t.ch - 1), c(t.line, t.ch + 1)); return i.length == 2 ? i : null; } function i(t, i, o) {
    const r = t.getLine(i.line),
      n = t.getTokenAt(i); if (/\bstring2?\b/.test(n.type)) return !1; const a = new e.StringStream(r.slice(0, i.ch) + o + r.slice(i.ch), 4); for (a.pos = a.start = n.start; ;) { const s = t.getMode().token(a, n.state); if (a.pos >= i.ch + 1) return /\bstring2?\b/.test(s); a.start = a.pos; }
  } function o(o, r) {
    for (var n = { name: 'autoCloseBrackets', Backspace(i) { if (i.getOption('disableInput')) return e.Pass; for (var r = i.listSelections(), n = 0; n < r.length; n++) { if (!r[n].empty()) return e.Pass; const a = t(i, r[n].head); if (!a || o.indexOf(a) % 2 != 0) return e.Pass; } for (var n = r.length - 1; n >= 0; n--) { const s = r[n].head; i.replaceRange('', c(s.line, s.ch - 1), c(s.line, s.ch + 1)); } } }, a = '', s = 0; s < o.length; s += 2) {
      (function(t, o) {
        a += o, n["'" + t + "'"] = function(n) {
          if (n.getOption('disableInput')) return e.Pass; for (var s, d, h = n.listSelections(), u = 0; u < h.length; u++) {
            var f,
              g = h[u],
              p = g.head,
              d = n.getRange(p, c(p.line, p.ch + 1)); if (g.empty()) if (t == o && d == o)f = n.getRange(p, c(p.line, p.ch + 3)) == t + t + t ? 'skipThree' : 'skip'; else if (t == o && p.ch > 1 && r.indexOf(t) >= 0 && n.getRange(c(p.line, p.ch - 2), p) == t + t && (p.ch <= 2 || n.getRange(c(p.line, p.ch - 3), c(p.line, p.ch - 2)) != t))f = 'addFour'; else if (t == '"' || t == "'") { if (e.isWordChar(d) || !i(n, p, t)) return e.Pass; f = 'both'; } else { if (!(n.getLine(p.line).length == p.ch || a.indexOf(d) >= 0 || l.test(d))) return e.Pass; f = 'both'; } else f = 'surround'; if (s) { if (s != f) return e.Pass; } else s = f;
          }n.operation(function() { if (s == 'skip')n.execCommand('goCharRight'); else if (s == 'skipThree') for (var e = 0; e < 3; e++)n.execCommand('goCharRight'); else if (s == 'surround') { for (var i = n.getSelections(), e = 0; e < i.length; e++)i[e] = t + i[e] + o; n.replaceSelections(i, 'around'); } else s == 'both' ? (n.replaceSelection(t + o, null), n.execCommand('goCharLeft')) : s == 'addFour' && (n.replaceSelection(t + t + t + t, 'before'), n.execCommand('goCharRight')); });
        }, t != o && (n["'" + o + "'"] = function(t) { for (let i = t.listSelections(), r = 0; r < i.length; r++) { const n = i[r]; if (!n.empty() || t.getRange(n.head, c(n.head.line, n.head.ch + 1)) != o) return e.Pass; }t.execCommand('goCharRight'); });
      })(o.charAt(s), o.charAt(s + 1));
    } return n;
  } function r(i) { return function(o) { if (o.getOption('disableInput')) return e.Pass; for (var r = o.listSelections(), n = 0; n < r.length; n++) { if (!r[n].empty()) return e.Pass; const a = t(o, r[n].head); if (!a || i.indexOf(a) % 2 != 0) return e.Pass; }o.operation(function() { o.replaceSelection('\n\n', null), o.execCommand('goCharLeft'), r = o.listSelections(); for (let e = 0; e < r.length; e++) { const t = r[e].head.line; o.indentLine(t, null, !0), o.indentLine(t + 1, null, !0); } }); }; } var n = "()[]{}''\"\"",
    a = "'\"",
    s = '[]{}',
    l = /\s/,
    c = e.Pos; e.defineOption('autoCloseBrackets', !1, function(t, i, l) {
    if (l != e.Init && l && t.removeKeyMap('autoCloseBrackets'), i) {
      let c = n,
        d = a,
        h = s; typeof i === 'string' ? c = i : typeof i === 'object' && (i.pairs != null && (c = i.pairs), i.triples != null && (d = i.triples), i.explode != null && (h = i.explode)); const u = o(c, d); h && (u.Enter = r(h)), t.addKeyMap(u);
    }
  });
}), function(e) { typeof exports === 'object' && typeof module === 'object' ? e(require('../../lib/codemirror')) : typeof define === 'function' && define.amd ? define([ '../../lib/codemirror' ], e) : e(CodeMirror); }(function(e) { 'use strict'; function t(e) { const t = e.getWrapperElement(); e.state.fullScreenRestore = { scrollTop: window.pageYOffset, scrollLeft: window.pageXOffset, width: t.style.width, height: t.style.height }, t.style.width = '', t.style.height = 'auto', t.className += ' CodeMirror-fullscreen', document.documentElement.style.overflow = 'hidden', e.refresh(); } function i(e) { const t = e.getWrapperElement(); t.className = t.className.replace(/\s*CodeMirror-fullscreen\b/, ''), document.documentElement.style.overflow = ''; const i = e.state.fullScreenRestore; t.style.width = i.width, t.style.height = i.height, window.scrollTo(i.scrollLeft, i.scrollTop), e.refresh(); }e.defineOption('fullScreen', !1, function(o, r, n) { n == e.Init && (n = !1), !n != !r && (r ? t(o) : i(o)); }); }), function(e) { typeof exports === 'object' && typeof module === 'object' ? e(require('../../lib/codemirror')) : typeof define === 'function' && define.amd ? define([ '../../lib/codemirror' ], e) : e(CodeMirror); }(function(e) {
  'use strict'; function t(e) { typeof e === 'object' && (this.minChars = e.minChars, this.style = e.style, this.showToken = e.showToken, this.delay = e.delay, this.wordsOnly = e.wordsOnly), this.style == null && (this.style = l), this.minChars == null && (this.minChars = s), this.delay == null && (this.delay = c), this.wordsOnly == null && (this.wordsOnly = d), this.overlay = this.timeout = null; } function i(e) { const t = e.state.matchHighlighter; clearTimeout(t.timeout), t.timeout = setTimeout(function() { o(e); }, t.delay); } function o(e) {
    e.operation(function() {
      const t = e.state.matchHighlighter; if (t.overlay && (e.removeOverlay(t.overlay), t.overlay = null), !e.somethingSelected() && t.showToken) { for (var i = t.showToken === !0 ? /[\w$]/ : t.showToken, o = e.getCursor(), n = e.getLine(o.line), s = o.ch, l = s; s && i.test(n.charAt(s - 1));)--s; for (;l < n.length && i.test(n.charAt(l));)++l; return void (l > s && e.addOverlay(t.overlay = a(n.slice(s, l), i, t.style))); } const c = e.getCursor('from'),
        d = e.getCursor('to'); if (c.line == d.line && (!t.wordsOnly || r(e, c, d))) { const h = e.getRange(c, d).replace(/^\s+|\s+$/g, ''); h.length >= t.minChars && e.addOverlay(t.overlay = a(h, !1, t.style)); }
    });
  } function r(e, t, i) {
    const o = e.getRange(t, i); if (o.match(/^\w+$/) !== null) {
      if (t.ch > 0) {
        var r = { line: t.line, ch: t.ch - 1 },
          n = e.getRange(r, t); if (n.match(/\W/) === null) return !1;
      } if (i.ch < e.getLine(t.line).length) {
        var r = { line: i.line, ch: i.ch + 1 },
          n = e.getRange(i, r); if (n.match(/\W/) === null) return !1;
      } return !0;
    } return !1;
  } function n(e, t) { return !(e.start && t.test(e.string.charAt(e.start - 1)) || e.pos != e.string.length && t.test(e.string.charAt(e.pos))); } function a(e, t, i) { return { token(o) { return !o.match(e) || t && !n(o, t) ? (o.next(), void (o.skipTo(e.charAt(0)) || o.skipToEnd())) : i; } }; } var s = 2,
    l = 'matchhighlight',
    c = 100,
    d = !1; e.defineOption('highlightSelectionMatches', !1, function(r, n, a) { if (a && a != e.Init) { const s = r.state.matchHighlighter.overlay; s && r.removeOverlay(s), clearTimeout(r.state.matchHighlighter.timeout), r.state.matchHighlighter = null, r.off('cursorActivity', i); }n && (r.state.matchHighlighter = new t(n), o(r), r.on('cursorActivity', i)); });
});
